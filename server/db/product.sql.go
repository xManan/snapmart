// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: product.sql

package db

import (
	"context"
	"database/sql"
)

const getProduct = `-- name: GetProduct :one
SELECT product_id, product_name, product_img_path, product_price, product_category_id, product_attributes FROM products 
WHERE product_id = ? LIMIT 1
`

func (q *Queries) GetProduct(ctx context.Context, productID int64) (Product, error) {
	row := q.queryRow(ctx, q.getProductStmt, getProduct, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.ProductImgPath,
		&i.ProductPrice,
		&i.ProductCategoryID,
		&i.ProductAttributes,
	)
	return i, err
}

const listProductsByCategoryId = `-- name: ListProductsByCategoryId :many
SELECT product_id, product_name, product_img_path, product_price, product_category_id, product_attributes FROM products 
WHERE product_category_id = ?
`

func (q *Queries) ListProductsByCategoryId(ctx context.Context, productCategoryID int64) ([]Product, error) {
	rows, err := q.query(ctx, q.listProductsByCategoryIdStmt, listProductsByCategoryId, productCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductImgPath,
			&i.ProductPrice,
			&i.ProductCategoryID,
			&i.ProductAttributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithCategory = `-- name: ListProductsWithCategory :many
SELECT 
    products.product_id, products.product_name, products.product_img_path, products.product_price, products.product_category_id, products.product_attributes, 
    c1.category_id, 
    c1.category_name, 
    c1.category_img_path, 
    c2.category_id AS category_parent_id,
    c2.category_name AS category_parent_name,
    c2.category_img_path AS category_parent_img_path 
FROM products
JOIN categories c1 ON products.product_category_id = c1.category_id
LEFT JOIN categories c2 ON c1.category_parent_id = c2.category_id
ORDER BY CASE
    WHEN c1.category_parent_id IS NULL THEN c1.category_id
    ELSE c1.category_parent_id
END
`

type ListProductsWithCategoryRow struct {
	ProductID             int64
	ProductName           string
	ProductImgPath        string
	ProductPrice          int64
	ProductCategoryID     int64
	ProductAttributes     sql.NullString
	CategoryID            int64
	CategoryName          string
	CategoryImgPath       string
	CategoryParentID      sql.NullInt64
	CategoryParentName    sql.NullString
	CategoryParentImgPath sql.NullString
}

func (q *Queries) ListProductsWithCategory(ctx context.Context) ([]ListProductsWithCategoryRow, error) {
	rows, err := q.query(ctx, q.listProductsWithCategoryStmt, listProductsWithCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithCategoryRow
	for rows.Next() {
		var i ListProductsWithCategoryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductImgPath,
			&i.ProductPrice,
			&i.ProductCategoryID,
			&i.ProductAttributes,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryImgPath,
			&i.CategoryParentID,
			&i.CategoryParentName,
			&i.CategoryParentImgPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
